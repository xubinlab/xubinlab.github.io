<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Numerical Methods, Solvers &amp; HPC | Xu Bin Lab</title>
  <meta name="description" content="Discretization methods, time integration, linear/nonlinear solvers, preconditioning, and HPC parallel computing for CFD applications." />
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="canonical" href="https://xubinlab.com/tech-stack/numerics-hpc.html" />
  <link rel="alternate" hreflang="zh-cn" href="https://xubinlab.com/zh/tech-stack/numerics-hpc.html" />
  <link rel="alternate" hreflang="en" href="https://xubinlab.com/tech-stack/numerics-hpc.html" />
  <script src="/assets/js/site-nav.js"></script>
</head>
<body>
<header id="site-nav"></header>

<main>
  <section id="numerics-hpc">
    <h2>Numerical Methods, Solvers &amp; HPC</h2>
    <p class="muted">
      This section addresses: how to discretize physical equations into computable forms,
      how to design solvers for stable and efficient convergence, and how to leverage multi-core, multi-node parallelism for large-scale cases.
    </p>

    <h3>1. Discretization Methods</h3>
    <p class="muted">
      Different frameworks (FVM / FEM / DG) have different applicable scenarios. Selection must consider both physical problem characteristics
      and subsequent solver complexity and parallel-friendliness.
    </p>
    <ul>
      <li><strong>1.1 Finite Volume Method (FVM)</strong> Control-volume based integral form, naturally conservative; suitable for convection-dominated CFD problems. Includes: reconstruction (linear, WENO), flux computation (Roe, AUSM+, HLLC), limiters.</li>
      <li><strong>1.2 Finite Element Method (FEM)</strong> Variational principle based, suitable for elliptic/parabolic problems, widely used in structural mechanics. In CFD, more common for incompressible flow, heat transfer.</li>
      <li><strong>1.3 Discontinuous Galerkin (DG)</strong> Combines FVM conservation and FEM high accuracy; suitable for high-precision needs and multiphysics coupling. Higher computational cost but advantages in specific scenarios.</li>
      <li><strong>1.4 Grid Types &amp; Adaptivity</strong> Structured/unstructured, polyhedral meshes, adaptive refinement; how grid types affect discretization and solving.</li>
    </ul>

    <h3>2. Time Integration</h3>
    <ul>
      <li><strong>2.1 Explicit Methods</strong> Runge-Kutta multi-step, timestep constraints (CFL condition), stability analysis. Suitable for convection-dominated, short timescale problems.</li>
      <li><strong>2.2 Implicit Methods</strong> Backward Euler, Crank-Nicolson, implicit Runge-Kutta. Larger timesteps possible but require linear/nonlinear system solving.</li>
      <li><strong>2.3 Dual Time Stepping</strong> Using explicit methods for pseudo-time in implicit framework; balances stability and efficiency. Widely used in compressible flow solvers.</li>
      <li><strong>2.4 Timestep Control</strong> Adaptive timesteps, local timesteps, multi-timescale problems (e.g., fast/slow reactions in combustion).</li>
    </ul>

    <h3>3. Linear Solvers</h3>
    <p class="muted">
      Core of implicit methods is solving sparse linear systems—this is the performance bottleneck and key to parallelization.
    </p>
    <ul>
      <li>
        <strong>3.1 Krylov Subspace Methods</strong>
        <ul>
          <li>CG (Conjugate Gradient): symmetric positive definite systems, common in structural mechanics.</li>
          <li>GMRES / BiCGStab: non-symmetric systems, typical for CFD Jacobian matrices.</li>
          <li>Restart strategies, convergence criteria, residual monitoring.</li>
        </ul>
      </li>
      <li>
        <strong>3.2 Preconditioning</strong>
        <ul>
          <li>Classical: Jacobi, Gauss-Seidel, ILU.</li>
          <li>Multigrid: V-cycle, W-cycle, highly effective in CFD.</li>
          <li>Approximate inverses, sparse approximate inverses (SPAI).</li>
          <li>Parallelization: how to parallelize without sacrificing effectiveness.</li>
        </ul>
      </li>
      <li><strong>3.3 Direct vs Iterative</strong> When to use direct (LU, Cholesky), when iterative is necessary. Trade-offs for large sparse systems.</li>
    </ul>

    <h3>4. Nonlinear Solvers</h3>
    <ul>
      <li><strong>4.1 Newton-Raphson</strong> Linearization of nonlinear systems, Jacobian construction (analytical vs numerical), convergence criteria.</li>
      <li><strong>4.2 Quasi-Newton</strong> BFGS, Broyden—avoid explicit Jacobian construction, suitable when Jacobian computation is expensive.</li>
      <li><strong>4.3 Nonlinear Preconditioning &amp; Damping</strong> Line search, trust region methods, improving Newton robustness.</li>
      <li><strong>4.4 Fully Coupled vs Segregated</strong> Pressure-velocity coupling (SIMPLE, PISO, Coupled), multiphysics coupling strategies.</li>
    </ul>

    <h3>5. HPC &amp; Parallel Computing</h3>
    <p class="muted">
      From single-core to multi-core, single-node to clusters: how to make algorithms fully utilize hardware resources.
    </p>
    <ul>
      <li>
        <strong>5.1 Parallel Models</strong>
        <ul>
          <li>OpenMP: shared memory, suitable for single-node multi-core.</li>
          <li>MPI: distributed memory, suitable for multi-node clusters.</li>
          <li>Hybrid: MPI + OpenMP, common on supercomputers.</li>
          <li>GPU: CUDA / OpenCL, suitable for data-parallel operators.</li>
        </ul>
      </li>
      <li>
        <strong>5.2 Domain Decomposition &amp; Load Balancing</strong>
        <ul>
          <li>METIS, ParMETIS for partitioning.</li>
          <li>Static vs dynamic load balancing for non-uniform computational loads.</li>
          <li>Minimizing inter-process communication, improving parallel efficiency.</li>
        </ul>
      </li>
      <li>
        <strong>5.3 Performance Optimization</strong>
        <ul>
          <li>Cache-friendly: data locality, memory access pattern optimization.</li>
          <li>Vectorization: SIMD instructions, compiler optimization.</li>
          <li>Profiling: gprof, perf, Intel VTune.</li>
          <li>Bottleneck identification: computation vs communication vs I/O.</li>
        </ul>
      </li>
    </ul>

    <h3>6. My Practice</h3>
    <p>Currently focused on:</p>
    <ul>
      <li>Implicit scheme design and implementation in compressible CFD solvers.</li>
      <li>Krylov solvers and multigrid preconditioners for sparse linear systems.</li>
      <li>Load balancing and communication optimization in MPI parallel contexts.</li>
      <li>Matrix operator acceleration and performance tuning on custom chips.</li>
    </ul>
    <p class="muted">
      Specific algorithm implementations, performance analysis, and optimization experience will be detailed in <a href="/projects/">projects</a> and <a href="/notes/">technical notes</a>.
    </p>
  </section>
</main>

<footer>
  © <span id="year"></span> Xu Bin Lab · Numerics &amp; HPC
</footer>
<script>
  document.getElementById('year').textContent = new Date().getFullYear();
</script>
</body>
</html>

