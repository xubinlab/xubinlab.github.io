<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI for Simulation / Coding / Chips | Xu Bin Lab</title>
  <meta name="description" content="Applications of AI tools (primarily LLMs) in simulation, coding, and chip performance analysis to improve efficiency and code quality." />
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="canonical" href="https://xubinlab.com/tech-stack/ai-sim-coding.html" />
  <link rel="alternate" hreflang="zh-cn" href="https://xubinlab.com/zh/tech-stack/ai-sim-coding.html" />
  <link rel="alternate" hreflang="en" href="https://xubinlab.com/tech-stack/ai-sim-coding.html" />
  <script src="/assets/js/site-nav.js"></script>
</head>
<body>
<header id="site-nav"></header>

<main>
  <section id="ai-sim-coding">
    <h2>AI for Simulation / Coding / Chips</h2>
    <p class="muted">
      This section discusses how to apply AI tools (primarily LLMs) to simulation, coding, and chip performance analysis.
      Focus is not on building large models, but "how to use AI in existing workflows" to improve efficiency and code quality.
    </p>

    <h3>1. AI + Simulation</h3>
    <p class="muted">
      In simulation workflows, AI can assist with model selection, parameter tuning, result interpretation,
      but must maintain physical constraints, numerical stability, and engineering verifiability as first principles.
    </p>
    <ul>
      <li>
        <strong>1.1 Model &amp; Parameter Selection</strong>
        <ul>
          <li>Model recommendations based on prior physics and numerical analysis: recommending suitable turbulence models, multiphase models for given conditions.</li>
          <li>Parameter tuning: intelligent selection of timesteps, convergence criteria, preconditioner parameters.</li>
          <li>Condition classification: automatically judging problem types from input conditions, selecting corresponding solution strategies.</li>
        </ul>
      </li>
      <li>
        <strong>1.2 Result Interpretation</strong>
        <ul>
          <li>Flow feature identification: automatically identifying shocks, separation zones, vortex structures.</li>
          <li>Anomaly detection: identifying unreasonable results, convergence anomalies.</li>
          <li>Trend analysis: extracting patterns from large case sets, assisting engineering decisions.</li>
        </ul>
      </li>
    </ul>

    <h3>2. AI + Coding</h3>
    <p class="muted">
      Using LLMs and other tools to assist C++ / Fortran development, improving coding efficiency and code quality.
    </p>
    <ul>
      <li>
        <strong>2.1 Code Generation &amp; Completion</strong>
        <ul>
          <li>Function implementation: generating base implementation code from interfaces and comments.</li>
          <li>Template code: generating templates for common patterns (iterators, factory patterns, etc.).</li>
          <li>Code completion: intelligent completion, context-aware code suggestions.</li>
        </ul>
      </li>
      <li>
        <strong>2.2 Code Refactoring &amp; Optimization</strong>
        <ul>
          <li>Refactoring suggestions: identifying code smells, providing refactoring solutions.</li>
          <li>Performance optimization: identifying bottlenecks, suggesting optimization directions.</li>
          <li>Code style: unifying code style, improving readability.</li>
        </ul>
      </li>
      <li>
        <strong>2.3 Testing &amp; Verification</strong>
        <ul>
          <li>Test case generation: automatically generating test cases from function interfaces.</li>
          <li>Boundary condition testing: identifying edge cases, generating targeted tests.</li>
          <li>Regression testing: learning from historical bugs, generating regression tests.</li>
        </ul>
      </li>
    </ul>

    <h3>3. AI + Chips</h3>
    <p class="muted">
      Using AI for bottleneck identification, parameter search, scheduling strategy exploration, not replacing architecture design.
    </p>
    <ul>
      <li>
        <strong>3.1 Performance Bottleneck Identification</strong>
        <ul>
          <li>Automatically identifying bottlenecks from performance data: computation, communication, I/O.</li>
          <li>Root cause analysis: deep analysis of bottleneck causes.</li>
          <li>Optimization suggestions: providing optimization directions based on historical experience.</li>
        </ul>
      </li>
      <li>
        <strong>3.2 Parameter Search &amp; Tuning</strong>
        <ul>
          <li>Hyperparameter search: efficient search for optimal configurations in parameter space.</li>
          <li>Scheduling strategy optimization: automatic optimization of task scheduling and resource allocation.</li>
        </ul>
      </li>
    </ul>

    <h3>4. My Practice</h3>
    <p>Currently focused on:</p>
    <ul>
      <li>Using LLMs to assist C++ code writing and refactoring, improving development efficiency.</li>
      <li>Using AI tools to assist simulation result analysis and problem diagnosis.</li>
      <li>Exploring AI applications in chip performance analysis and scheduling optimization.</li>
      <li>Establishing quality assurance processes for AI-assisted development, ensuring code correctness.</li>
    </ul>
    <p class="muted">
      Specific AI application scenarios, usage experience, and effectiveness evaluation will be detailed in <a href="/projects/">projects</a> and <a href="/notes/">technical notes</a>.
      Emphasis: AI is a tool, not a replacement; physical constraints and engineering verifiability remain first principles.
    </p>
  </section>
</main>

<footer>
  © <span id="year"></span> Xu Bin Lab · AI Applications
</footer>
<script>
  document.getElementById('year').textContent = new Date().getFullYear();
</script>
</body>
</html>

