<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Designing a Compressible CFD Solver for Custom Scientific Computing Chips | Xu Bin Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Notes on designing a compressible CFD solver for custom scientific computing chips: equations, discretization, sparse solvers, and hardware-aware data layout." />
  <style>
    :root {
      --bg: #020617;
      --fg: #e5e7eb;
      --fg-muted: #9ca3af;
      --accent: #38bdf8;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 45%, #000 100%);
      color: var(--fg);
      line-height: 1.7;
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 24px 16px 64px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(30, 64, 175, 0.6);
    }
    .brand {
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: 0.9rem;
      color: var(--fg-muted);
    }
    nav a {
      font-size: 0.9rem;
      margin-left: 16px;
      color: var(--fg-muted);
    }
    nav a:hover { color: var(--fg); }
    @media (max-width: 640px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      nav { display: flex; flex-wrap: wrap; }
      nav a { margin: 4px 12px 0 0; }
    }
    h1 {
      font-size: clamp(1.9rem, 3vw, 2.4rem);
      margin-top: 24px;
      margin-bottom: 8px;
    }
    .meta {
      font-size: 0.85rem;
      color: var(--fg-muted);
      margin-bottom: 16px;
    }
    h2 {
      font-size: 1.1rem;
      margin-top: 28px;
      margin-bottom: 6px;
    }
    h3 {
      font-size: 1rem;
      margin-top: 18px;
      margin-bottom: 4px;
    }
    p {
      margin: 0 0 10px;
      font-size: 0.95rem;
    }
    ul {
      margin: 4px 0 10px 20px;
      font-size: 0.95rem;
    }
    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      background: rgba(15, 23, 42, 0.9);
      padding: 1px 4px;
      border-radius: 4px;
    }
    blockquote {
      margin: 8px 0 12px;
      padding-left: 12px;
      border-left: 2px solid rgba(148, 163, 184, 0.7);
      color: var(--fg-muted);
      font-size: 0.92rem;
    }
    .tagline {
      font-size: 0.95rem;
      color: var(--fg-muted);
      margin-bottom: 16px;
    }
    footer {
      margin-top: 40px;
      font-size: 0.8rem;
      color: var(--fg-muted);
      border-top: 1px solid rgba(30, 64, 175, 0.6);
      padding-top: 12px;
    }
  </style>
</head>
<body>
  <div class="page">
    <header id="site-nav"></header>
    <script src="/assets/js/site-nav.js"></script>

    <main>
      <h1>Designing a Compressible CFD Solver for Custom Scientific Computing Chips</h1>
      <div class="meta">
        Draft · Language: English · Author: Xu Bin  
      </div>

      <p class="tagline">
        This note summarizes how I think about designing a compressible CFD solver that
        runs efficiently on a custom scientific computing chip, while still behaving like
        a serious engineering tool: verifiable, robust, and maintainable.
      </p>

      <h2>1. Context and Goals</h2>
      <p>
        In many CFD projects, the solver is written with a generic CPU cluster in mind.
        When we introduce a <strong>custom scientific computing chip</strong> into the picture,
        several things change at once:
      </p>
      <ul>
        <li>Memory bandwidth and on-chip storage become the primary bottlenecks.</li>
        <li>Vectorization and instruction-level parallelism are exposed much more explicitly.</li>
        <li>Data movement across chip boundaries (PCIe, NoC, etc.) can easily dominate cost.</li>
      </ul>
      <p>
        From my experience, a reasonable goal is to:
      </p>
      <ul>
        <li>Keep the solver <strong>physically honest</strong> enough for engine simulation (fan, compressor, combustor, turbine).</li>
        <li>Restructure the code so that the <strong>most expensive kernels</strong> map cleanly onto the chip.</li>
        <li>Build a development workflow where accuracy and performance can both be regression-tested.</li>
      </ul>

      <h2>2. Equations and Discretization: What Must Not Change</h2>
      <p>
        On the mathematical side, I try not to “simplify away” the problem just to fit the chip.
        For compressible flow, the core choice is:
      </p>
      <ul>
        <li>Governing equations: 3D compressible Navier–Stokes in conservative form.</li>
        <li>Discretization: finite volume (FVM) on unstructured grids, with RANS / LES turbulence models.</li>
        <li>Time integration: fully implicit or strongly implicit schemes, leading to large sparse linear systems.</li>
      </ul>
      <p>
        These choices are largely <strong>hardware-agnostic</strong> and driven by physics and engineering requirements.
        The chip enters the picture when we look at:
      </p>
      <ul>
        <li>How we store the mesh and unknowns.</li>
        <li>How we assemble and apply the discrete operators.</li>
        <li>How we solve the resulting linear systems.</li>
      </ul>

      <h2>3. Data Layout and Memory Bandwidth</h2>
      <p>
        On a bandwidth-limited accelerator, <strong>data layout is part of the numerical method</strong>.
        For a cell-centered FVM solver, typical choices include:
      </p>
      <ul>
        <li><strong>Structure of Arrays (SoA)</strong> for conservative variables and residuals.</li>
        <li>Compressed sparse formats (CSR / BCSR / ELL) for matrix-free and matrix-based operators.</li>
        <li>Reordering (e.g., RCM, space-filling curves) to improve locality.</li>
      </ul>
      <p>
        The goal is not just to “make it faster”, but to make memory access patterns
        <strong>predictable enough</strong> so that the chip’s prefetchers, local memories, and
        DMA engines can actually be used.
      </p>

      <h2>4. Sparse Linear Solvers on the Chip</h2>
      <p>
        In an implicit compressible solver, most of the time is spent in sparse linear solvers:
        typically <strong>BiCGStab</strong>, <strong>CG</strong>, or related Krylov methods, plus a preconditioner.
      </p>
      <p>
        On a custom chip, I see three layers:
      </p>
      <h3>4.1 Algorithmic layer</h3>
      <p>
        At this level we decide:
      </p>
      <ul>
        <li>Which Krylov method is appropriate for each block (pressure, momentum, energy).</li>
        <li>How aggressive the preconditioner can be without breaking robustness.</li>
        <li>How tightly we couple the flow and turbulence variables.</li>
      </ul>

      <h3>4.2 Kernel layer</h3>
      <p>
        Here we look at kernels such as:
      </p>
      <ul>
        <li>SpMV / SpMM on custom sparse formats.</li>
        <li>Dot products and vector updates (AXPY, fused operations).</li>
        <li>Restriction / prolongation operations in multigrid settings.</li>
      </ul>
      <p>
        These kernels must be designed with:
      </p>
      <ul>
        <li>Vector width and alignment requirements.</li>
        <li>Local memory capacity and banking.</li>
        <li>DMA transaction sizes and overlap with computation.</li>
      </ul>

      <h3>4.3 Mapping layer</h3>
      <p>
        Finally, we decide how to map the mesh and linear algebra objects onto:
      </p>
      <ul>
        <li>Chip tiles / cores / compute clusters.</li>
        <li>On-chip vs off-chip memory.</li>
        <li>PCIe or NoC links when running multi-chip configurations.</li>
      </ul>

      <h2>5. Verification, Regression, and “Not Lying to Yourself”</h2>
      <p>
        When chasing performance, it is easy to accidentally change the math.
        To avoid this, I try to build a verification and regression stack that includes:
      </p>
      <ul>
        <li>
          <strong>Canonical test cases</strong>: SOD tube, RAE2822, engine fan/compressor stages,
          and gradually more realistic combustor / turbine cases.
        </li>
        <li>
          <strong>Metric baselines</strong>: lift/drag, pressure ratios, efficiency, and residual histories,
          compared against trusted references.
        </li>
        <li>
          <strong>Hash-based checks</strong> on mesh and boundary inputs to catch silent file corruption.
        </li>
      </ul>
      <p>
        The idea is that every time we change data layout, kernel implementation, or chip mapping,
        we can re-run a selected set of cases and confirm that the engineering answers remain within
        acceptable tolerances.
      </p>

      <h2>6. Towards a Full Engine Simulation Workflow</h2>
      <p>
        Ultimately, a solver is only useful if it fits into an end-to-end workflow:
      </p>
      <ul>
        <li>Reading meshes from commercial tools (no re-meshing).</li>
        <li>Handling realistic boundary conditions from engine engineers.</li>
        <li>Writing results to open formats for post-processing.</li>
      </ul>
      <p>
        On a custom chip, this usually implies:
      </p>
      <ul>
        <li>A CPU-side orchestration layer that prepares data and launches chip kernels.</li>
        <li>A clear separation between <em>physics modules</em> and <em>hardware-specific backends</em>.</li>
        <li>Automation around performance testing on real machines, not just micro-benchmarks.</li>
      </ul>

      <h2>7. Closing Remarks</h2>
      <p>
        This note is intentionally high-level. In future updates, I plan to fill in more details on:
      </p>
      <ul>
        <li>Concrete sparse formats and kernel designs that worked (and failed) on our chip.</li>
        <li>Trade-offs between matrix-free and matrix-based implementations.</li>
        <li>How we organize the CFD codebase so that algorithm research and chip deployment share the same core.</li>
      </ul>
      <p>
        If you are working on similar problems and would like to compare notes, feel free to reach out at
        <a href="mailto:xubinlab@gmail.com">xubinlab@gmail.com</a>.
      </p>
    </main>

    <footer>
      © <span id="year"></span> Xu Bin Lab · Technical Notes.
    </footer>
  </div>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
</body>
</html>
